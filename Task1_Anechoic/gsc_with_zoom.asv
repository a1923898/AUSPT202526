% gsc with variable zoom
% parameter 'zoom_percentage':
%   0.0: wide mode (delay-and-sum). captures target + ambiance.
%   0.5: standard cancellation. removes specific interference.
%   1.0: super-zoom (gsc + post-filtering)


% zoom parameter - between 0 and 1
zoom_percentage = 1; 

% load data & setup
filename = 'output_mixture.wav';
if ~isfile(filename), error('Run the simulation script first to generate output_mixture.wav'); end
[x, fs] = audioread(filename);

% simulation parameters
d = 0.08; c = 340; mic_locs = [-d/2, d/2]; theta_target = 90;

% STFT setup
win_len = 512; overlap = 256; fft_len = 512;
[S, f, t_stft] = stft(x, fs, 'Window', hamming(win_len), 'OverlapLength', overlap, 'FFTLength', fft_len);
[num_bins, num_frames, num_mics] = size(S);

Y_zoom_stft = zeros(num_bins, num_frames);

% GSC loop
for k = 1:num_bins
    freq = f(k);
    k_wave = 2*pi*freq/c;
    
    % alignment (upper rail)
    steering_vec = exp(1j * k_wave * mic_locs' * cosd(theta_target));
    X_k = squeeze(S(k, :, :)).';
    X_aligned = X_k ./ steering_vec;
    
    d_upper = mean(X_aligned, 1);       % fixed beamformer (wide)
    u_lower = X_aligned(1,:) - X_aligned(2,:); % blocking matrix
    
    % adaptive weight calculation ---
    R_du = (u_lower * d_upper') / num_frames;
    R_uu = (u_lower * u_lower') / num_frames; 
    R_uu = R_uu + 1e-6 * mean(abs(u_lower).^2); % stability
    w_adapt = R_du / R_uu;
    
    % apply zoom logic ---
    
    % linear zoom (interference rejection)
    % at zoom 0, we subtract nothing (weight = 0).
    % at zoom 1, we subtract the full interference (weight = w_adapt).    
    % calculate linear output
    y_linear = d_upper - (zoom_percentage * w_adapt' * u_lower);
    
    % high-zoom post-filter (non-linear narrowing)
    % we calculate how much noise was present compared to the signal.
    % if the blocking matrix (u_lower) has high energy, we suppress the output
    
    if zoom_percentage > 0.5

        aggressiveness = (zoom_percentage - 0.5) * 4;
        
        % estimate SNR at this frequency
        power_upper = abs(d_upper).^2;
        power_lower = abs(w_adapt' * u_lower).^2;
        
        % wiener-like gain mask: g = signal / (signal + noise)
        gain_mask = power_upper ./ (power_upper + aggressiveness * power_lower + 1e-9);
        
        % apply mask
        Y_zoom_stft(k, :) = y_linear .* gain_mask;
    else
        % no post-filtering for lower zoom percentages
        Y_zoom_stft(k, :) = y_linear;
    end
end

% 4. Reconstruction
y_zoom = istft(Y_zoom_stft, fs, 'Window', hamming(win_len), 'OverlapLength', overlap, 'FFTLength', fft_len);
len = min(length(x), length(y_zoom));
y_zoom = y_zoom(1:len);
x_ref = x(1:len, 1);

% Normalize
y_zoom = y_zoom / max(abs(y_zoom)) * 0.9;

% 5. Visualization
t_vec = (0:len-1)/fs;

figure('Name', ['Audio Zoom Level: ' num2str(zoom_percentage)]);
subplot(3,1,1);
plot(t_vec, x_ref); title('Mic 1 (Input)'); grid on; ylim([-1 1]);

subplot(3,1,2);
plot(t_vec, y_zoom); 
title(['Zoom Output (Level ' num2str(zoom_percentage) ')']); 
grid on; ylim([-1 1]);

subplot(3,1,3);
spectrogram(y_zoom, 256, 128, 256, fs, 'yaxis');
title('Output Spectrogram');

outfile = sprintf('result_zoom_%d.wav', round(zoom_percentage*100));
audiowrite(outfile, y_zoom, fs);
fprintf('Saved output to %s\n', outfile);